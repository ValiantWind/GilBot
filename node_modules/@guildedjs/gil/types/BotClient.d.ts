import Collection from "@discordjs/collection";
import { Client, Message } from "guilded.js";
import type { Argument } from "./structures/Argument";
import type { Command } from "./structures/Command";
import type { Inhibitor } from "./structures/Inhibitor";
import type { Monitor } from "./structures/Monitor";
import type Task from "./structures/Task";
export declare class BotClient extends Client {
    options: BotClientOptions;
    /** All your bot's monitors will be available here */
    monitors: Collection<string, Monitor>;
    /** All your bot's commands will be available here */
    commands: Collection<string, Command>;
    /** All your bot's arguments will be available here */
    arguments: Collection<string, Argument>;
    /** All your bot's inhibitors will be available here */
    inhibitors: Collection<string, Inhibitor>;
    /** All your bot's tasks will be available here */
    tasks: Collection<string, Task>;
    /** The bot's prefixes per team. <teamId, prefix> */
    prefixes: Map<string, string>;
    /** The message collectors that are pending. */
    messageCollectors: Collection<string, MessageCollector>;
    /** The path that the end users commands,monitors, inhibitors and others will be located. */
    sourceFolderPath: string;
    constructor(options: BotClientOptions, autoInit?: boolean);
    /** Get the default client prefix. */
    get prefix(): string;
    /** Get the bot's mention. Guilded api does not provide a way to dynamically detect this so for now its manual. */
    get botMention(): string | undefined;
    loadFile(result: any, dir: string, collection: Collection<string, any>): Promise<void>;
    /** Prepares the bot to run. Ideally used for loading files to the bot. */
    init(): Promise<void>;
    /** Allows users to override and customize the addition of a event listener */
    initializeMessageListener(): void;
    /** Allows users to override and customize the initialization of scheduled task intervals. */
    initializeTasks(): void;
    /** Handler to execute a task when it is time. */
    executeTask(task: Task): Promise<void>;
    /** Handler that is run on messages and can  */
    processMonitors(message: Message): void;
    humanizeMilliseconds(milliseconds: number): string;
    stringToMilliseconds(text: string): number | undefined;
    needMessage(userId: string, channelId: string, options?: MessageCollectorOptions & {
        amount?: 1;
    }): Promise<Message>;
    needMessage(userId: string, channelId: string, options: MessageCollectorOptions & {
        amount?: number;
    }): Promise<Message[]>;
    collectMessages(options: CollectMessagesOptions): Promise<Message[]>;
    getTime(): string;
}
export interface BotClientOptions {
    /** The prefix that will be used to determine if a message is executing a command. */
    prefix: string;
    /** The path that the end users commands, monitors, inhibitors and others will be located. */
    sourceFolderPath?: string;
    /** The path to a custom dir where commands are located. */
    commandDirPath?: string;
    /** The path to a custom dir where the monitors are located */
    monitorDirPath?: string;
    /** The path to a custom dir where the inhibitors are located */
    inhibitorDirPath?: string;
    /** The bot mention. Most likely @botname This is required as Guilded does not currently give any way to dynamically detect the mention. */
    botMention?: string;
    token: string;
}
export interface MessageCollectorOptions {
    /** Function that will filter messages to determine whether to collect this message. Defaults to making sure the message is sent by the same member. */
    filter?: (message: Message) => boolean;
    /** The amount of messages to collect before resolving. Defaults to 1 */
    amount?: number;
    /** The amount of milliseconds this should collect for before expiring. Defaults to 5 minutes. */
    duration?: number;
}
export interface CollectMessagesOptions {
    /** The unique key that will be used to get responses for this. Ideally, meant to be for member id. */
    key: string;
    /** The amount of messages to collect before resolving. */
    amount: number;
    /** The timestamp when this collector was created */
    createdAt: number;
    /** The duration in milliseconds how long this collector should last. */
    duration: number;
    /** The channel Id where this is listening to */
    channelId: string;
    /** Function that will filter messages to determine whether to collect this message */
    filter: (message: Message) => boolean;
}
export interface MessageCollector extends CollectMessagesOptions {
    resolve: (value: Message[] | PromiseLike<Message[]>) => void;
    reject: (reason?: any) => void;
    /** Where the messages are stored if the amount to collect is more than 1. */
    messages: Message[];
}
export default BotClient;
//# sourceMappingURL=BotClient.d.ts.map