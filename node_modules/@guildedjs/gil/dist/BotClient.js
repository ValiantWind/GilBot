"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BotClient = void 0;
const collection_1 = __importDefault(require("@discordjs/collection"));
const colorette_1 = require("colorette");
const guilded_js_1 = require("guilded.js");
const path_1 = __importDefault(require("path"));
const walk_1 = require("./utils/walk");
class BotClient extends guilded_js_1.Client {
    constructor(options, autoInit = true) {
        super(options);
        this.options = options;
        /** All your bot's monitors will be available here */
        this.monitors = new collection_1.default();
        /** All your bot's commands will be available here */
        this.commands = new collection_1.default();
        /** All your bot's arguments will be available here */
        this.arguments = new collection_1.default();
        /** All your bot's inhibitors will be available here */
        this.inhibitors = new collection_1.default();
        /** All your bot's tasks will be available here */
        this.tasks = new collection_1.default();
        /** The bot's prefixes per team. <teamId, prefix> */
        this.prefixes = new Map();
        /** The message collectors that are pending. */
        this.messageCollectors = new collection_1.default();
        /** The path that the end users commands,monitors, inhibitors and others will be located. */
        this.sourceFolderPath = this.options.sourceFolderPath || path_1.default.join(process.cwd(), "src/");
        if (autoInit)
            void this.init();
    }
    /** Get the default client prefix. */
    get prefix() {
        return this.options.prefix;
    }
    /** Get the bot's mention. Guilded api does not provide a way to dynamically detect this so for now its manual. */
    get botMention() {
        return this.options.botMention;
    }
    loadFile(result, dir, collection) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const [filename, file] = result;
            const { name } = path_1.default.parse(filename);
            const piece = file.default ? new file.default(this, name) : new file(this, name);
            let cmd = undefined;
            if (dir === "commands" && piece.parentCommand) {
                const subcommandNames = piece.parentCommand.split("-");
                for (const subname of subcommandNames) {
                    // LOOK FOR MAIN COMMAND
                    if (!cmd) {
                        const mainCmd = collection.get(subname);
                        if (mainCmd) {
                            cmd = mainCmd;
                            continue;
                        }
                        else {
                            throw new Error(`You tried to create a subcommand named ${piece.name}. However, the parent command, ${subname}, was not found.`);
                        }
                    }
                    const subcmd = (_a = cmd === null || cmd === void 0 ? void 0 : cmd.subcommands) === null || _a === void 0 ? void 0 : _a.get(subname);
                    if (subcmd) {
                        cmd = subcmd;
                        continue;
                    }
                    else {
                        throw new Error(`You tried to create a subcommand named ${piece.name} inside the main command ${cmd.name}. However, the parent command, ${subname}, was not found.`);
                    }
                }
            }
            if (cmd) {
                if (!cmd.subcommands)
                    cmd.subcommands = new collection_1.default();
                cmd.subcommands.set(piece.name || name, piece);
            }
            else {
                collection.set(piece.name || name, piece);
            }
            if (piece.init)
                yield piece.init();
        });
    }
    /** Prepares the bot to run. Ideally used for loading files to the bot. */
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.allSettled([
                ["monitors", this.monitors],
                ["commands", this.commands],
                ["arguments", this.arguments],
                ["inhibitors", this.inhibitors],
                ["tasks", this.tasks],
            ].map(([dir, collection]) => __awaiter(this, void 0, void 0, function* () {
                var e_1, _a;
                try {
                    try {
                        for (var _b = __asyncValues((0, walk_1.walk)(path_1.default.join(__dirname, dir))), _c; _c = yield _b.next(), !_c.done;) {
                            const result = _c.value;
                            yield this.loadFile(result, dir, collection);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                catch (error) {
                    console.log(error);
                }
            }))).catch(() => null);
            // Load all end user files
            yield Promise.allSettled([
                ["monitors", this.monitors],
                ["commands", this.commands],
                ["arguments", this.arguments],
                ["inhibitors", this.inhibitors],
                ["tasks", this.tasks],
            ].map(([dir, collection]) => __awaiter(this, void 0, void 0, function* () {
                var e_2, _d;
                var _e;
                try {
                    try {
                        for (var _f = __asyncValues((0, walk_1.walk)((_e = this.options.monitorDirPath) !== null && _e !== void 0 ? _e : path_1.default.join(this.sourceFolderPath, dir))), _g; _g = yield _f.next(), !_g.done;) {
                            const result = _g.value;
                            yield this.loadFile(result, dir, collection);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_g && !_g.done && (_d = _f.return)) yield _d.call(_f);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                catch (error) {
                    console.log(error);
                }
            }))).catch(() => null);
            this.initializeMessageListener();
            this.initializeTasks();
        });
    }
    /** Allows users to override and customize the addition of a event listener */
    initializeMessageListener() {
        this.on("messageCreated", (message) => this.processMonitors(message));
    }
    /** Allows users to override and customize the initialization of scheduled task intervals. */
    initializeTasks() {
        this.tasks.forEach((task) => __awaiter(this, void 0, void 0, function* () {
            // TASKS THAT NEED TO RUN IMMEDIATELY ARE EXECUTED FIRST
            if (task.runOnStartup)
                yield this.executeTask(task);
            // SET TIMEOUT WILL DETERMINE THE RIGHT TIME TO RUN THE TASK FIRST TIME AFTER STARTUP
            setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                yield this.executeTask(task);
                setInterval(() => __awaiter(this, void 0, void 0, function* () {
                    yield this.executeTask(task);
                }), task.millisecondsInterval);
            }), Date.now() % task.millisecondsInterval);
        }));
    }
    /** Handler to execute a task when it is time. */
    executeTask(task) {
        return __awaiter(this, void 0, void 0, function* () {
            // IF TASK REQUIRES BOT BEING FULLY READY EXIT OUT IF BOT ISN'T READY
            if (task.requireReady && !this.readyTimestamp)
                return;
            console.log(`${(0, colorette_1.bgBlue)(`[${this.getTime()}]`)} [TASK: ${(0, colorette_1.bgYellow)((0, colorette_1.black)(task.name))}] started.`);
            const started = Date.now();
            try {
                yield task.execute();
                console.log(`${(0, colorette_1.bgBlue)(`[${this.getTime()}]`)} [TASK: ${(0, colorette_1.bgGreen)((0, colorette_1.black)(task.name))}] executed in ${this.humanizeMilliseconds(Date.now() - started)}.`);
            }
            catch (error) {
                console.log(error);
            }
        });
    }
    /** Handler that is run on messages and can  */
    processMonitors(message) {
        this.monitors.forEach((monitor) => {
            var _a;
            if (monitor.ignoreBots && (message.createdByBotId || message.createdByWebhookId))
                return;
            if (monitor.ignoreOthers && message.createdByBotId !== ((_a = this.user) === null || _a === void 0 ? void 0 : _a.botId))
                return;
            if (monitor.ignoreEdits && message.updatedAt && message.updatedAt !== message.createdAt)
                return;
            // TODO: When the api supports using dm channels
            // if (monitor.ignoreDM && !message.teamId) return;
            void monitor.execute(message);
        });
    }
    humanizeMilliseconds(milliseconds) {
        // Gets ms into seconds
        const time = milliseconds / 1000;
        if (time < 1)
            return "1s";
        const days = Math.floor(time / 86400);
        const hours = Math.floor((time % 86400) / 3600);
        const minutes = Math.floor(((time % 86400) % 3600) / 60);
        const seconds = Math.floor(((time % 86400) % 3600) % 60);
        const dayString = days ? `${days}d ` : "";
        const hourString = hours ? `${hours}h ` : "";
        const minuteString = minutes ? `${minutes}m ` : "";
        const secondString = seconds ? `${seconds}s ` : "";
        return `${dayString}${hourString}${minuteString}${secondString}`;
    }
    stringToMilliseconds(text) {
        const matches = text.match(/(\d+[w|d|h|m|s]{1})/g);
        if (!matches)
            return;
        let total = 0;
        for (const match of matches) {
            // Finds the first of these letters
            const validMatch = /(w|d|h|m|s)/.exec(match);
            // if none of them were found cancel
            if (!validMatch)
                return;
            // Get the number which should be before the index of that match
            const number = match.substring(0, validMatch.index);
            // Get the letter that was found
            const [letter] = validMatch;
            if (!number || !letter)
                return;
            let multiplier = 1000;
            switch (letter.toLowerCase()) {
                case `w`:
                    multiplier = 1000 * 60 * 60 * 24 * 7;
                    break;
                case `d`:
                    multiplier = 1000 * 60 * 60 * 24;
                    break;
                case `h`:
                    multiplier = 1000 * 60 * 60;
                    break;
                case `m`:
                    multiplier = 1000 * 60;
                    break;
            }
            const amount = number ? parseInt(number, 10) : undefined;
            if (!amount && amount !== 0)
                return;
            total += amount * multiplier;
        }
        return total;
    }
    needMessage(userId, channelId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const messages = yield this.collectMessages({
                key: userId,
                channelId,
                createdAt: Date.now(),
                filter: (options === null || options === void 0 ? void 0 : options.filter) || ((msg) => userId === msg.createdById),
                amount: (options === null || options === void 0 ? void 0 : options.amount) || 1,
                // DEFAULTS TO 5 MINUTES
                duration: (options === null || options === void 0 ? void 0 : options.duration) || 300000,
            });
            return ((options === null || options === void 0 ? void 0 : options.amount) || 1) > 1 ? messages : messages[0];
        });
    }
    collectMessages(options) {
        return new Promise((resolve, reject) => {
            var _a;
            (_a = this.messageCollectors.get(options.key)) === null || _a === void 0 ? void 0 : _a.reject("A new collector began before the user responded to the previous one.");
            this.messageCollectors.set(options.key, Object.assign(Object.assign({}, options), { messages: [], resolve,
                reject }));
        });
    }
    getTime() {
        const now = new Date();
        const hours = now.getHours();
        const minute = now.getMinutes();
        let hour = hours;
        let amOrPm = `AM`;
        if (hour > 12) {
            amOrPm = `PM`;
            hour -= 12;
        }
        return `${hour >= 10 ? hour : `0${hour}`}:${minute >= 10 ? minute : `0${minute}`} ${amOrPm}`;
    }
}
exports.BotClient = BotClient;
exports.default = BotClient;
//# sourceMappingURL=BotClient.js.map