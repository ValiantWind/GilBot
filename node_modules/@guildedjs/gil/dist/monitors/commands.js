"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandsMonitor = void 0;
const colorette_1 = require("colorette");
const Monitor_1 = require("../structures/Monitor");
class CommandsMonitor extends Monitor_1.Monitor {
    constructor() {
        super(...arguments);
        // Commands should not ignore dms.
        this.ignoreDM = false;
    }
    execute(message) {
        let prefix = this.parsePrefix(message.serverId);
        // If the message is not using the valid prefix or bot mention cancel the command
        // IF THE MESSAGE IS ONLY BOT MENTION, SEND THE PREFIX
        if (this.client.botMention) {
            if (this.client.botMention === message.content)
                return this.client.messages.send(message.channelId, { content: this.parsePrefix(message.serverId), replyMessageIds: [message.id] });
            // IF THE MESSAGE STARTS WITH BOT MENTION, USE MENTION AS PREFIX
            else if (message.content.startsWith(this.client.botMention))
                prefix = this.client.botMention;
        }
        // IF NO PREFIX IS USED, CANCEL
        if (!message.content.startsWith(prefix))
            return;
        // `!ping testing` becomes `ping`
        const [commandName, ...parameters] = message.content.substring(prefix.length).split(" ");
        // Check if this is a valid command
        const command = this.parseCommand(commandName);
        if (!command)
            return;
        this.logCommand(message, "Trigger", commandName);
        // TODO: implement a global user cooldown system
        void this.executeCommand(message, command, parameters);
    }
    parsePrefix(serverId) {
        const prefix = serverId ? this.client.prefixes.get(serverId) : this.client.prefix;
        return prefix || this.client.prefix;
    }
    parseCommand(commandName) {
        commandName = commandName.toLowerCase();
        const command = this.client.commands.get(commandName);
        if (command)
            return command;
        // Check aliases if the command wasn't found
        return this.client.commands.find((cmd) => { var _a; return Boolean((_a = cmd.aliases) === null || _a === void 0 ? void 0 : _a.includes(commandName)); });
    }
    logCommand(message, type, commandName) {
        // TODO: use server name when available in api
        const serverName = message.serverId || "DM";
        const command = `[COMMAND: ${(0, colorette_1.bgYellow)((0, colorette_1.black)(commandName || "Unknown"))} - ${(0, colorette_1.bgBlack)(["Failure", "Slowmode", "Missing"].includes(type) ? (0, colorette_1.red)(type) : type === "Success" ? (0, colorette_1.green)(type) : (0, colorette_1.white)(type))}]`;
        // TODO: use message author tag or name here
        const user = (0, colorette_1.bgGreen)((0, colorette_1.black)(`${""}(${message.createdById})`));
        const guild = (0, colorette_1.bgMagenta)((0, colorette_1.black)(`${serverName}${message.serverId ? `(${message.serverId})` : ""}`));
        console.log(`${(0, colorette_1.bgBlue)(`[${this.client.getTime()}]`)} ${command} by ${user} in ${guild} with Message ID: ${message.id}`);
    }
    executeCommand(message, command, parameters) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // bot.slowmode.set(message.author.id, message.timestamp);
                // Parsed args and validated
                const args = yield this.parseArguments(message, command, parameters);
                // Some arg that was required was missing and handled already
                if (!args)
                    return this.logCommand(message, "Missing", command.name);
                // If no subcommand execute the command
                const [argument] = command.arguments || [];
                const subcommand = argument ? args[argument.name] : undefined;
                if (!argument || argument.type !== "subcommand" || !subcommand) {
                    // Check subcommand permissions and options
                    if (!(yield this.commandAllowed(message, command)))
                        return;
                    yield ((_a = command.execute) === null || _a === void 0 ? void 0 : _a.call(command, message, args));
                    return this.logCommand(message, "Success", command.parentCommand ? `${command.parentCommand}-${command.name}` : command.name);
                }
                // A subcommand was asked for in this command
                if ([subcommand.name, ...(subcommand.aliases || [])].includes(parameters[0])) {
                    const subParameters = parameters.slice(1);
                    void this.executeCommand(message, subcommand, subParameters);
                }
                else {
                    void this.executeCommand(message, subcommand, parameters);
                }
            }
            catch (error) {
                console.error(error);
                this.logCommand(message, "Failure", command.name);
            }
        });
    }
    parseArguments(message, command, parameters) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const args = {};
            if (!command.arguments)
                return args;
            let missingRequiredArg = false;
            // Clone the parameters so we can modify it without editing original array
            const params = [...parameters];
            // Loop over each argument and validate
            for (const argument of command.arguments) {
                const resolver = this.client.arguments.get(argument.type || "string");
                if (!resolver)
                    continue;
                const result = yield resolver.execute(argument, params, message, command);
                if (result !== undefined) {
                    // Assign the valid argument
                    args[argument.name] = result;
                    // This will use up all args so immediately exist the loop.
                    if (argument.type && ["subcommands", "...strings", "...roles", "...emojis", "...snowflakes"].includes(argument.type)) {
                        break;
                    }
                    // Remove a param for the next argument
                    params.shift();
                    continue;
                }
                // Invalid arg provided.
                if (Object.prototype.hasOwnProperty.call(argument, "defaultValue")) {
                    args[argument.name] = argument.defaultValue;
                }
                else if (argument.required !== false) {
                    if (argument.missing) {
                        missingRequiredArg = true;
                        (_a = argument.missing) === null || _a === void 0 ? void 0 : _a.call(argument, message);
                        break;
                    }
                    // A REQUIRED ARG WAS MISSING TRY TO COLLECT IT
                    // TODO: perm check before sending
                    const question = yield this.client.messages.send(message.channelId, {
                        content: `You were missing the **${argument.name}** argument which is required in that command. Please provide the **${argument.type === "subcommand" ? ((_b = command.subcommands) === null || _b === void 0 ? void 0 : _b.map((sub) => sub.name).join(", ")) || "subcommand" : argument.type}** now.`,
                        replyMessageIds: [message.id],
                    });
                    if (question) {
                        const response = yield this.client.needMessage(message.createdById, message.channelId);
                        if (response) {
                            const responseArg = yield resolver.execute(argument, [response.content], message, command);
                            if (responseArg) {
                                args[argument.name] = responseArg;
                                params.shift();
                                // TODO: perm checks to delete message
                                yield Promise.all([
                                    this.client.messages.delete(message.channelId, message.id),
                                    this.client.messages.delete(message.channelId, response.id),
                                ]);
                                continue;
                            }
                        }
                    }
                    missingRequiredArg = true;
                    // @ts-ignore fix this dumb error. TODO: idk why this is erroring
                    (_c = argument.missing) === null || _c === void 0 ? void 0 : _c.call(argument, message);
                    break;
                }
            }
            // If an arg was missing then return false so we can error out as an object {} will always be truthy
            return missingRequiredArg ? false : args;
        });
    }
    commandAllowed(message, command) {
        return __awaiter(this, void 0, void 0, function* () {
            const inhibitorResults = yield Promise.all([...this.client.inhibitors.values()].map((inhibitor) => inhibitor.execute(message, command)));
            if (inhibitorResults.includes(true)) {
                this.logCommand(message, "Inhibit", command.name);
                return false;
            }
            return true;
        });
    }
    init() {
        return void 0;
    }
}
exports.CommandsMonitor = CommandsMonitor;
exports.default = CommandsMonitor;
//# sourceMappingURL=commands.js.map