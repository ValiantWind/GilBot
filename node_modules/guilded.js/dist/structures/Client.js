"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const rest_1 = require("@guildedjs/rest");
const ws_1 = require("@guildedjs/ws");
const node_events_1 = require("node:events");
const ClientGatewayHandler_1 = require("../gateway/ClientGatewayHandler");
const ChannelManager_1 = require("../managers/global/ChannelManager");
const DocManager_1 = require("../managers/global/DocManager");
const ForumManager_1 = require("../managers/global/ForumManager");
const GroupManager_1 = require("../managers/global/GroupManager");
const ListManager_1 = require("../managers/global/ListManager");
const MemberManager_1 = require("../managers/global/MemberManager");
const MessageManager_1 = require("../managers/global/MessageManager");
const RoleManager_1 = require("../managers/global/RoleManager");
const UserManager_1 = require("../managers/global/UserManager");
const GuildBanManager_1 = require("../managers/global/GuildBanManager");
const WebhookManager_1 = require("../managers/global/WebhookManager");
const User_1 = require("./User");
class Client extends node_events_1.EventEmitter {
    constructor(options) {
        if (typeof options !== "object")
            throw new Error("Must provide options in client constructor in the form of an object.");
        if (typeof (options === null || options === void 0 ? void 0 : options.token) === "undefined")
            throw new Error("No token provided.");
        super();
        this.options = options;
        /** The time in milliseconds since the Client connected */
        this.readyTimestamp = null;
        /** The manager for the bot to make requests to the REST api. */
        this.rest = new rest_1.RestManager(Object.assign(Object.assign({}, this.options.rest), { token: this.options.token }));
        /** The websocket connection */
        this.ws = new ws_1.WebSocketManager({ token: this.options.token });
        /** The gateway event handlers will be processed by this manager. */
        this.gatewayHandler = new ClientGatewayHandler_1.ClientGatewayHandler(this);
        /** Managers for structures */
        this.channels = new ChannelManager_1.GlobalChannelManager(this);
        this.docs = new DocManager_1.GlobalDocManager(this);
        this.forums = new ForumManager_1.GlobalForumManager(this);
        this.groups = new GroupManager_1.GlobalGroupManager(this);
        this.lists = new ListManager_1.GlobalListItemManager(this);
        this.members = new MemberManager_1.GlobalMemberManager(this);
        this.messages = new MessageManager_1.GlobalMessageManager(this);
        this.roles = new RoleManager_1.GlobalRoleManager(this);
        this.users = new UserManager_1.GlobalUserManager(this);
        this.bans = new GuildBanManager_1.GlobalGuildBanManager(this);
        this.webhooks = new WebhookManager_1.GlobalWebhookManager(this);
        /** The user belonging to this bot */
        this.user = null;
    }
    /** The amount of time the bot has been online in milliseconds. */
    get uptime() {
        return this.readyTimestamp ? Date.now() - this.readyTimestamp : 0;
    }
    /** The bot's token. */
    get token() {
        return this.options.token;
    }
    /** Connects the bot to the api. */
    login(opts) {
        if (opts === null || opts === void 0 ? void 0 : opts.fresh)
            this.ws = new ws_1.WebSocketManager({ token: this.options.token });
        this.ws.emitter
            .on("error", (reason, err) => this.emit("error", `[WS] ${reason}`, err))
            .on("ready", (user) => {
            this.user = new User_1.ClientUser(this, user);
            this.readyTimestamp = Date.now();
            this.emit("ready");
        })
            .on("gatewayEvent", (event, data) => this.gatewayHandler.handleWSMessage(event, data))
            .on("debug", (data) => this.emit("debug", data))
            .on("exit", () => this.emit("exit"));
        this.ws.connect();
    }
    /** Disconnects the bot. */
    disconnect() {
        if (!this.ws.isAlive)
            throw new Error("There is no active connection to disconnect.");
        this.ws.emitter.removeAllListeners();
        this.ws.destroy();
        this.emit("exit");
    }
}
exports.Client = Client;
//# sourceMappingURL=Client.js.map