"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeamMemberEventHandler = void 0;
const constants_1 = require("../../constants");
const structures_1 = require("../../structures");
const GatewayEventHandler_1 = require("./GatewayEventHandler");
const util_1 = require("../../util");
class TeamMemberEventHandler extends GatewayEventHandler_1.GatewayEventHandler {
    teamMemberUpdated(data) {
        const member = this.client.members.cache.get((0, util_1.buildMemberKey)(data.d.serverId, data.d.userInfo.id));
        if (!member)
            return this.client.emit(constants_1.constants.clientEvents.MEMBER_UPDATED, data.d, null);
        const oldMember = member._clone();
        member._update({ nickname: data.d.userInfo.nickname });
        return this.client.emit(constants_1.constants.clientEvents.MEMBER_UPDATED, member, oldMember);
    }
    teamMemberJoined(data) {
        const newMember = new structures_1.Member(this.client, Object.assign(Object.assign({}, data.d.member), { serverId: data.d.serverId, id: data.d.member.user.id }));
        const newUser = new structures_1.User(this.client, data.d.member.user);
        this.client.members.cache.set((0, util_1.buildMemberKey)(data.d.serverId, data.d.member.user.id), newMember);
        this.client.users.cache.set(newUser.id, newUser);
        if (data.d.member.user.id === this.client.user.id)
            this.client.emit(constants_1.constants.clientEvents.SERVER_CREATED, { serverId: data.d.serverId });
        return this.client.emit(constants_1.constants.clientEvents.MEMBER_JOINED, newMember);
    }
    teamMemberRemoved(data) {
        var _a, _b;
        const memberKey = (0, util_1.buildMemberKey)(data.d.serverId, data.d.userId);
        const existingMember = this.client.members.cache.get(memberKey);
        if ((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.removeMemberOnLeave)
            this.client.members.cache.delete(memberKey);
        return this.client.emit(constants_1.constants.clientEvents.MEMBER_REMOVED, (_b = existingMember === null || existingMember === void 0 ? void 0 : existingMember._update({ kicked: data.d.isKick, banned: data.d.isBan })) !== null && _b !== void 0 ? _b : data.d);
    }
    teamMemberBanned(data) {
        var _a;
        const newMemberBan = new structures_1.MemberBan(this.client, Object.assign({ serverId: data.d.serverId }, data.d.serverMemberBan));
        if (((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.cacheMemberBans) !== false)
            this.client.bans.cache.set((0, util_1.buildMemberKey)(newMemberBan.serverId, newMemberBan.target.id), newMemberBan);
        return this.client.emit(constants_1.constants.clientEvents.MEMBER_BANNED, newMemberBan);
    }
    teamMemberUnbanned(data) {
        var _a;
        const memberKey = (0, util_1.buildMemberKey)(data.d.serverId, data.d.serverMemberBan.user.id);
        const existingMemberBan = this.client.bans.cache.get(memberKey);
        if (existingMemberBan && ((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.removeMemberOnLeave))
            this.client.bans.cache.delete(existingMemberBan.id);
        const existingMember = this.client.members.cache.get(memberKey);
        if (existingMember)
            existingMember._update({ banned: false });
        return this.client.emit(constants_1.constants.clientEvents.MEMBER_UNBANNED, existingMemberBan !== null && existingMemberBan !== void 0 ? existingMemberBan : data.d);
    }
}
exports.TeamMemberEventHandler = TeamMemberEventHandler;
//# sourceMappingURL=TeamMemberEventHandler.js.map