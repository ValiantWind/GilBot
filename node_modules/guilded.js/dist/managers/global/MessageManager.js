"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalMessageManager = void 0;
const Message_1 = require("../../structures/Message");
const CacheableStructManager_1 = require("./CacheableStructManager");
const collection_1 = __importDefault(require("@discordjs/collection"));
const util_1 = require("../../util");
class GlobalMessageManager extends CacheableStructManager_1.CacheableStructManager {
    /** Get a list of the latest 50 messages from a channel. */
    fetchMany(channelId, options) {
        return this.client.rest.router.getChannelMessages(channelId, options).then((data) => {
            const messages = new collection_1.default();
            for (const message of data.messages) {
                const newMessage = new Message_1.Message(this.client, message);
                messages.set(newMessage.id, newMessage);
            }
            return messages;
        });
    }
    /** Get details for a specific chat message from a chat channel. */
    fetch(channelId, messageId, force) {
        if (!force) {
            const existingMessage = this.client.messages.cache.get(messageId);
            if (existingMessage)
                return Promise.resolve(existingMessage);
        }
        return this.client.rest.router.getChannelMessage(channelId, messageId).then((data) => {
            const newMessage = new Message_1.Message(this.client, data.message);
            this.client.messages.cache.set(newMessage.id, newMessage);
            return newMessage;
        });
    }
    /** Send a message in a channel */
    send(channelId, content) {
        return this.client.rest.router.createChannelMessage(channelId, (0, util_1.resolveContentToData)(content)).then((data) => {
            // This is in the case of which the WS gateway beats us to adding the message to the cache. If they haven't, then we do it ourselves.
            const existingMessage = this.client.messages.cache.get(data.message.id);
            if (existingMessage)
                return existingMessage;
            const newMessage = new Message_1.Message(this.client, data.message);
            this.client.messages.cache.set(newMessage.id, newMessage);
            return newMessage;
        });
    }
    /** Add a reaction emote */
    addReaction(channelId, contentId, emoteId) {
        return this.client.rest.router.addReactionEmote(channelId, contentId, emoteId).then(() => void 0);
    }
    /** Update a channel message. */
    update(channelId, messageId, content) {
        return this.client.rest.router.updateChannelMessage(channelId, messageId, (0, util_1.resolveContentToData)(content)).then((data) => {
            // This is in the case of which the WS gateway beats us to modifying the message in the cache. If they haven't, then we do it ourselves.
            const existingMessage = this.client.messages.cache.get(data.message.id);
            if (existingMessage)
                return existingMessage._update(data.message);
            const newMessage = new Message_1.Message(this.client, data.message);
            this.client.messages.cache.set(newMessage.id, newMessage);
            return newMessage;
        });
    }
    /** Delete a channel message. */
    delete(channelId, messageId) {
        return this.client.rest.router.deleteChannelMessage(channelId, messageId).then(() => void 0);
    }
}
exports.GlobalMessageManager = GlobalMessageManager;
//# sourceMappingURL=MessageManager.js.map