"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalWebhookManager = void 0;
const collection_1 = __importDefault(require("@discordjs/collection"));
const Webhook_1 = require("../../structures/Webhook");
const CacheableStructManager_1 = require("./CacheableStructManager");
class GlobalWebhookManager extends CacheableStructManager_1.CacheableStructManager {
    get _shouldCacheWebhook() {
        var _a;
        return ((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.cacheWebhooks) !== false;
    }
    /** Create a webhook */
    createWebhook(serverId, options) {
        return this.client.rest.router.createWebhook(serverId, options).then((data) => {
            // This is in the case of which the WS gateway beats us to adding the message to the cache. If they haven't, then we do it ourselves.
            const existingWebhook = this.client.webhooks.cache.get(data.webhook.id);
            if (existingWebhook)
                return existingWebhook;
            const newWebhook = new Webhook_1.Webhook(this.client, data.webhook);
            if (this._shouldCacheWebhook)
                this.cache.set(newWebhook.id, newWebhook);
            return newWebhook;
        });
    }
    /** Get a server's webhooks */
    getWebhooks(serverId, channelId) {
        return this.client.rest.router.getWebhooks(serverId, channelId).then((data) => {
            const webhooks = new collection_1.default();
            for (const webhook of data.webhooks) {
                const newWebhook = new Webhook_1.Webhook(this.client, webhook);
                webhooks.set(newWebhook.id, newWebhook);
                if (this._shouldCacheWebhook)
                    this.cache.set(newWebhook.id, newWebhook);
            }
            return webhooks;
        });
    }
    /** Get a webhook */
    getWebhook(serverId, webhookId, force) {
        if (!force) {
            const existingWebhook = this.client.webhooks.cache.get(webhookId);
            if (existingWebhook)
                return Promise.resolve(existingWebhook);
        }
        return this.client.rest.router.getWebhook(serverId, webhookId).then((data) => {
            const newWebhook = new Webhook_1.Webhook(this.client, data.webhook);
            if (this._shouldCacheWebhook)
                this.cache.set(newWebhook.id, newWebhook);
            return newWebhook;
        });
    }
    /** Update a webhook */
    updateWebhook(serverId, webhookId, options) {
        return this.client.rest.router.updateWebhook(serverId, webhookId, options).then((data) => {
            var _a, _b;
            return (_b = (_a = this.cache.get(data.webhook.id)) === null || _a === void 0 ? void 0 : _a._update(data.webhook)) !== null && _b !== void 0 ? _b : new Webhook_1.Webhook(this.client, data.webhook);
        });
    }
    /** Delete a webhook */
    deleteWebhook(serverId, webhookId) {
        return this.client.rest.router.deleteWebhook(serverId, webhookId);
    }
}
exports.GlobalWebhookManager = GlobalWebhookManager;
//# sourceMappingURL=WebhookManager.js.map