"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalMemberManager = void 0;
const structures_1 = require("../../structures");
const Member_1 = require("../../structures/Member");
const CacheableStructManager_1 = require("./CacheableStructManager");
const collection_1 = __importDefault(require("@discordjs/collection"));
const util_1 = require("../../util");
class GlobalMemberManager extends CacheableStructManager_1.CacheableStructManager {
    /** Fetch a member from a server */
    fetch(serverId, memberId, force) {
        const memberKey = (0, util_1.buildMemberKey)(serverId, memberId);
        if (!force) {
            const existingMember = this.client.members.cache.get(memberKey);
            if (existingMember)
                return Promise.resolve(existingMember);
        }
        return this.client.rest.router.getMember(serverId, memberId).then((data) => {
            const newMember = new Member_1.Member(this.client, Object.assign(Object.assign({}, data.member), { serverId, id: data.member.user.id }));
            this.client.users.cache.set(data.member.user.id, new structures_1.User(this.client, data.member.user));
            this.client.members.cache.set(memberKey, newMember);
            return newMember;
        });
    }
    /** Fetch all members from a server. Returned objects are partial members */
    fetchMany(serverId) {
        return this.client.rest.router.getMembers(serverId).then((data) => {
            const members = new collection_1.default();
            for (const member of data.members) {
                const newMember = new Member_1.PartialMember(this.client, Object.assign({ serverId, id: member.user.id }, member));
                members.set(newMember.id, newMember);
            }
            return members;
        });
    }
    /** Kick a member from a server */
    kick(serverId, memberId) {
        return this.client.rest.router.kickMember(serverId, memberId).then((_) => { var _a; return (_a = this.client.members.cache.get((0, util_1.buildMemberKey)(serverId, memberId))) !== null && _a !== void 0 ? _a : null; });
    }
    /** Get a list of the roles assigned to a member using the id of the member. */
    getRoles(serverId, memberId) {
        return this.client.rest.router.getMemberRoles(serverId, memberId).then((data) => data.roleIds);
    }
    /** Update a member's nickname. Returns the new name */
    updateNickname(serverId, memberId, newNickname) {
        return this.client.rest.router.updateMemberNickname(serverId, memberId, newNickname).then((data) => data.nickname);
    }
    /** Delete a member's nickname */
    resetNickname(serverId, memberId) {
        return this.client.rest.router.deleteMemberNickname(serverId, memberId).then(() => void 0);
    }
    /** Award XP to a member */
    giveXP(serverId, memberId, amount) {
        return this.client.rest.router.awardMemberXP(serverId, memberId, amount).then((data) => data.total);
    }
    /** Retrieves a member's public social links */
    fetchSocialLinks(serverId, memberId, type) {
        return this.client.rest.router.getMemberSocialLinks(serverId, memberId, type).then((data) => data.socialLink);
    }
}
exports.GlobalMemberManager = GlobalMemberManager;
//# sourceMappingURL=MemberManager.js.map