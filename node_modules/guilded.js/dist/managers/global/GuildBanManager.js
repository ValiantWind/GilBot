"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalGuildBanManager = void 0;
const collection_1 = __importDefault(require("@discordjs/collection"));
const Member_1 = require("../../structures/Member");
const CacheableStructManager_1 = require("./CacheableStructManager");
const util_1 = require("../../util");
class GlobalGuildBanManager extends CacheableStructManager_1.CacheableStructManager {
    get shouldCacheBan() {
        var _a;
        return ((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.cacheMemberBans) !== false;
    }
    /** Fetch a member ban in a server */
    fetch(serverId, userId, force) {
        if (!force) {
            const existingMemberBan = this.client.bans.cache.get((0, util_1.buildMemberKey)(serverId, userId));
            if (existingMemberBan)
                return Promise.resolve(existingMemberBan);
        }
        return this.client.rest.router.getMemberBan(serverId, userId).then((data) => {
            const newMemberBan = new Member_1.MemberBan(this.client, Object.assign(Object.assign({}, data.serverMemberBan), { serverId }));
            if (this.shouldCacheBan)
                this.client.bans.cache.set(newMemberBan.id, newMemberBan);
            return newMemberBan;
        });
    }
    /** Fetch all bans in a server */
    fetchMany(serverId) {
        return this.client.rest.router.getMemberBans(serverId).then((data) => {
            const newMemberBans = new collection_1.default();
            for (const ban of data.serverMemberBans) {
                const newMemberBan = new Member_1.MemberBan(this.client, Object.assign({ serverId }, ban));
                newMemberBans.set(newMemberBan.id, newMemberBan);
                if (this.shouldCacheBan)
                    this.client.bans.cache.set(newMemberBan.id, newMemberBan);
            }
            return newMemberBans;
        });
    }
    /** Ban a user from a server */
    ban(serverId, userId) {
        return this.client.rest.router.banMember(serverId, userId).then((data) => {
            const newMemberBan = new Member_1.MemberBan(this.client, Object.assign({ serverId }, data.serverMemberBan));
            if (this.shouldCacheBan)
                this.client.bans.cache.set(newMemberBan.id, newMemberBan);
            return newMemberBan;
        });
    }
    /** Unban a user from a server. Returns existing ban if cached. */
    unban(serverId, userId, removeBanIfCached = false) {
        return this.client.rest.router.unbanMember(serverId, userId).then((data) => {
            var _a;
            const memberKey = (0, util_1.buildMemberKey)(serverId, userId);
            const existingBan = this.client.bans.cache.get(memberKey);
            if (((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.removeMemberOnLeave) || removeBanIfCached)
                this.client.bans.cache.delete(memberKey);
            return existingBan !== null && existingBan !== void 0 ? existingBan : null;
        });
    }
}
exports.GlobalGuildBanManager = GlobalGuildBanManager;
//# sourceMappingURL=GuildBanManager.js.map